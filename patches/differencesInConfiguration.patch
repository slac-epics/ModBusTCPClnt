diff --git a/configure/CONFIG_APP b/configure/CONFIG_APP
new file mode 100644
index 0000000..b1f4ba1
--- /dev/null
+++ b/configure/CONFIG_APP
@@ -0,0 +1,21 @@
+# CONFIG_APP
+
+include $(TOP)/configure/RELEASE
+-include $(TOP)/configure/RELEASE.$(EPICS_HOST_ARCH)
+-include $(TOP)/configure/RELEASE.Common.$(T_A)
+-include $(TOP)/configure/RELEASE.$(EPICS_HOST_ARCH).$(T_A)
+
+CONFIG=$(EPICS_BASE)/configure
+include $(CONFIG)/CONFIG
+
+INSTALL_LOCATION = $(TOP)
+ifdef INSTALL_LOCATION_APP
+INSTALL_LOCATION = $(INSTALL_LOCATION_APP)
+endif
+
+ifdef T_A
+-include $(TOP)/configure/O.$(T_A)/CONFIG_APP_INCLUDE
+endif
+
+# dbst based database optimization (default: NO)
+DB_OPT = NO
diff --git a/configure/RULES.iocBoot b/configure/RULES.iocBoot
new file mode 100644
index 0000000..7bb3b3b
--- /dev/null
+++ b/configure/RULES.iocBoot
@@ -0,0 +1,4 @@
+#RULES.iocBoot
+DIRS += $(wildcard *ioc*)
+DIRS += $(wildcard as*)
+include $(EPICS_BASE)/configure/RULES_DIRS
diff --git a/configure/convApp b/configure/convApp
new file mode 100644
index 0000000..9d3967b
--- /dev/null
+++ b/configure/convApp
@@ -0,0 +1,129 @@
+#!/bin/bash
+#
+# R3.13 to R3.14 App conversion script..  Does the most basic stuff in 
+# "Converting an EPICS R3.13 application to R3.14.1" -- 
+#
+# requires:
+# 1.  first argument is cvs module name of app
+# 2.  start directory has snsTemplates directory installed
+# 3.  There are some absolute paths in script.
+#
+# Carl Lionberger 4 Feb 2003 SNS-ORNL
+#
+condir=$PWD
+mv work work`date -Iseconds`
+mkdir work
+cd work
+cvs export -r HEAD $1
+rm -rf ${1}314
+mkdir ${1}314
+cd ${1}314
+/ade/epics/supTop/base/R3.14.4/bin/linux-x86/makeBaseApp.pl -T $condir/snsTemplates/makeBaseApp/top -t snsVxApp junk
+rm -rf junkApp
+rm -rf config
+targ=$PWD
+cd ../$1
+find *App iocBoot -print | cpio -pvmd $targ
+cd $targ/configure
+mv RELEASE RELEASE.orig
+sed -e '/#SNCSEQ/a\
+SNCSEQ=/ade/epics/supTop/share/R3.14.4/seq-2.0.7' \
+    < RELEASE.orig > RELEASE
+rm RELEASE.orig
+cd $targ
+for d in `ls -d *App`
+do
+   cd $d
+   echo "Modifying $d"
+   mv Makefile Makefile.orig
+   sed -e '/config/s//configure/' \
+       -e '/CONFIG_APP/s//CONFIG/' \
+       < Makefile.orig > Makefile
+   rm Makefile.orig
+if test -d Db 
+then
+      echo "Modifying Db Makefile"
+      cd Db
+      rm Makefile
+      sed -e '/^TOP/c\
+TOP=../..' \
+          -e '/config/s//configure/' \
+          -e '/CONFIG_APP/s//CONFIG/' \
+          -e '/RULES.Db/s//RULES/' \
+          < Makefile.Host > Makefile
+      rm Makefile.Host
+      cd .. 
+fi
+if test -d src
+then
+      echo "Modifying src Makefile"
+      cd src
+      rm Makefile
+      cp $condir/snsTemplates/makeBaseApp/top/snsVxApp/src/Makefile \
+            ./Makefile314
+      srcMakeCon
+      rm Makefile314 Makefile.Host Makefile.Vx
+      cd .. 
+fi
+if test -d srcOpi
+then 
+   cd srcOpi
+   echo "Modifying srcOpi Makefile"
+   rm Makefile
+   sed -e '/^TOP/i\
+T_A=$EPICS_HOST_ARCH' \
+        -e '/^TOP/c\
+TOP=../..' \
+       -e '/config/s//configure/' \
+       -e '/CONFIG_APP/s//CONFIG/' \
+       < Makefile.Host > Makefile
+   rm Makefile.Host
+   cd .. 
+fi
+if test -d srcCfg
+then 
+   cd srcCfg
+   for cd in `ls -d *Cfg`
+   do
+      cd $cd
+      echo "Modifying srcCfg/$cd Makefile"
+      rm Makefile
+      sed -e '/^TOP/c\
+TOP=../../..' \
+          -e '/config/s//configure/' \
+          -e '/CONFIG_APP/s//CONFIG/' \
+          < Makefile.Host > Makefile
+          rm Makefile.Host
+      cd .. 
+   done
+   cd ..
+fi
+   rm -rf srcAdl
+   echo "$d done"
+   cd ..
+done
+if test -d $targ/iocBoot; then 
+   cd $targ/iocBoot
+   mv Makefile Makefile.orig
+   echo 'Modifying iocBoot Makefile'
+   sed -e '/config/s//configure/' \
+       -e '/CONFIG_APP/s//CONFIG/' \
+       -e '/^DIRS/d' \
+       < Makefile.orig > Makefile
+   rm Makefile.orig
+   for id in `ls -d *ioc*`
+   do
+      cd $id
+      echo "Modifying $id  Makefile"
+      mv Makefile Makefile.orig
+      sed -e '/config/s//configure/' \
+          -e '/CONFIG_APP/s//CONFIG/' \
+          -e '/ARCH =/c\
+ARCH=vxWorks-ppc603' \
+          -e '/^buildInstall/d' \
+         < Makefile.orig > Makefile
+          rm Makefile.orig
+      cd ..
+   done;
+fi
+                  
diff --git a/configure/convShare b/configure/convShare
new file mode 100644
index 0000000..2831c62
--- /dev/null
+++ b/configure/convShare
@@ -0,0 +1,129 @@
+#!/bin/bash
+#
+# R3.13 to R3.14 App conversion script..  Does the most basic stuff in 
+# "Converting an EPICS R3.13 application to R3.14.1" -- 
+#
+# requires:
+# 1.  first argument is cvs module name of app
+# 2.  start directory has snsTemplates directory installed
+# 3.  There are some absolute paths in script.
+#
+# Carl Lionberger 4 Feb 2003 SNS-ORNL
+#
+condir=$PWD
+mv work work`date -Iseconds`
+mkdir work
+cd work
+cvs export -r HEAD $1
+rm -rf ${1}314
+mkdir ${1}314
+cd ${1}314
+/ade/epics/supTop/base/R3.14.4/bin/linux-x86/makeBaseApp.pl -T $condir/snsTemplates/makeBaseApp/top -t snsShareApp junk
+rm -rf junkApp
+rm -rf config
+targ=$PWD
+cd ../$1
+find *App iocBoot -print | cpio -pvmd $targ
+cd $targ/configure
+mv RELEASE RELEASE.orig
+sed -e '/#SNCSEQ/a\
+SNCSEQ=/ade/epics/supTop/share/R3.14.4/seq-2.0.7' \
+    < RELEASE.orig > RELEASE
+rm RELEASE.orig
+cd $targ
+for d in `ls -d *App`
+do
+   cd $d
+   echo "Modifying $d"
+   mv Makefile Makefile.orig
+   sed -e '/config/s//configure/' \
+       -e '/CONFIG_APP/s//CONFIG/' \
+       < Makefile.orig > Makefile
+   rm Makefile.orig
+if test -d Db 
+then
+      echo "Modifying Db Makefile"
+      cd Db
+      rm Makefile
+      sed -e '/^TOP/c\
+TOP=../..' \
+          -e '/config/s//configure/' \
+          -e '/CONFIG_APP/s//CONFIG/' \
+          -e '/RULES.Db/s//RULES/' \
+          < Makefile.Host > Makefile
+      rm Makefile.Host
+      cd .. 
+fi
+if test -d src
+then
+      echo "Modifying src Makefile"
+      cd src
+      rm Makefile
+      cp $condir/snsTemplates/makeBaseApp/top/snsShareApp/src/Makefile \
+            ./Makefile314
+      srcMakeCon
+      rm Makefile314 Makefile.Host Makefile.Vx
+      cd .. 
+fi
+if test -d srcOpi
+then 
+   cd srcOpi
+   echo "Modifying srcOpi Makefile"
+   rm Makefile
+   sed -e '/^TOP/i\
+T_A=$EPICS_HOST_ARCH' \
+        -e '/^TOP/c\
+TOP=../..' \
+       -e '/config/s//configure/' \
+       -e '/CONFIG_APP/s//CONFIG/' \
+       < Makefile.Host > Makefile
+   rm Makefile.Host
+   cd .. 
+fi
+if test -d srcCfg
+then 
+   cd srcCfg
+   for cd in `ls -d *Cfg`
+   do
+      cd $cd
+      echo "Modifying srcCfg/$cd Makefile"
+      rm Makefile
+      sed -e '/^TOP/c\
+TOP=../../..' \
+          -e '/config/s//configure/' \
+          -e '/CONFIG_APP/s//CONFIG/' \
+          < Makefile.Host > Makefile
+          rm Makefile.Host
+      cd .. 
+   done
+   cd ..
+fi
+   rm -rf srcAdl
+   echo "$d done"
+   cd ..
+done
+if test -d $targ/iocBoot; then 
+   cd $targ/iocBoot
+   mv Makefile Makefile.orig
+   echo 'Modifying iocBoot Makefile'
+   sed -e '/config/s//configure/' \
+       -e '/CONFIG_APP/s//CONFIG/' \
+       -e '/^DIRS/d' \
+       < Makefile.orig > Makefile
+   rm Makefile.orig
+   for id in `ls -d *ioc*`
+   do
+      cd $id
+      echo "Modifying $id  Makefile"
+      mv Makefile Makefile.orig
+      sed -e '/config/s//configure/' \
+          -e '/CONFIG_APP/s//CONFIG/' \
+          -e '/ARCH =/c\
+ARCH=vxWorks-ppc603' \
+          -e '/^buildInstall/d' \
+         < Makefile.orig > Makefile
+          rm Makefile.orig
+      cd ..
+   done;
+fi
+                  
diff --git a/configure/makeRegistrar b/configure/makeRegistrar
new file mode 100644
index 0000000..f976d39
--- /dev/null
+++ b/configure/makeRegistrar
@@ -0,0 +1,266 @@
+#!/usr/bin/perl
+#
+# makeRegistrar 
+#
+# Takes [ansi vanilla] function prototypes and produces EPICS registrar 
+# function.
+#
+
+# output is to be inserted into code containing functions to be registered.
+# Note the registrar function and its export call both use the program name 
+# "xxx", which you need to change by hand.  
+
+#
+# be sure to include "iocsh.h" and "epicsExport.h" in the file.
+#
+
+# Example prototypes from autoSaveRestore:
+#  
+#    Clip these and use as test input if desired.  Remove the ^#
+#
+#int set_savefile_name(char *filename, char *save_filename);
+#int create_periodic_set(char *filename, int period, char *macrostring);
+#int create_triggered_set(char *filename, char *trigger_channel,
+#        char *macrostring);
+#int create_monitor_set(char *filename, int period, char *macrostring);
+#int create_manual_set(char *filename, char *macrostring);
+#int fdbrestore(char *filename);
+#void fdblist(int verbose);
+#
+#int set_requestfile_path(char *path, char *pathsub);
+#int set_savefile_path(char *path, char *pathsub);
+#int set_saveTask_priority(int priority);
+#int remove_data_set(char *filename);
+#int reload_periodic_set(char *filename, int period, char *macrostring);
+#int reload_triggered_set(char *filename, char *trigger_channel,
+#        char *macrostring);
+#int reload_monitor_set(char * filename, int period, char *macrostring);
+#int reload_manual_set(char * filename, char *macrostring);
+#int fdbrestoreX(char *filename);
+#
+
+
+#
+# input
+#
+$i = 0;
+while (<>) {
+#  chomp();
+   @inlist[$i] = $_;
+   $i++;
+}
+
+#
+# combine broken lines
+#
+$i = 0;$untermed=0;
+foreach (@inlist) {
+   if (!/;$/) {
+      chomp;
+      @outlist[$i] = $_;
+      $untermed = 1;
+   }
+   else {
+      if ($untermed == 1) {
+         $untermed = 0; 
+         @outlist[$i] = join("",@outlist[$i],$_);   
+      }  else {
+         @outlist[$i] = $_;
+      }
+      $i++;
+   }
+}
+#print @outlist;
+
+#get args 
+
+$i = 0;
+foreach (@outlist) {
+   ($junk, $arglist) = split("[(]",$_);
+   ($arglist, $junk) = split("[)]",$arglist);
+   @allargs[$i] = $arglist . "\n";
+   $i++;
+}
+
+#
+# produce argument descriptors, arg lists, funcdefs, callfuncs
+#
+
+   $i = 0;
+   $funcfound = 0;
+   foreach (@allargs) {
+      #
+      # note that is block of code is repeated below, to catch last
+      # member of list.  
+      #
+      if ($funcfound == 1) {
+         $funcfound = 0;
+         print "static const iocshArg * const ".$funcname."Args\[" . $j ."\] = {\n";
+         for ($k = 0; $k < $j; $k++) {
+            print "       &" . $funcname . "Arg" . $k;
+            if (($k + 1) < $j) {
+                print ",\n"; 
+            } else { print "\};\n"}
+         }
+         print "static const iocshFuncDef " . $funcname . "FuncDef = {";
+         print "\"". $funcname ."\"," . $j . "\," . $funcname."Args};\n";
+         print "static void " . $funcname . "CallFunc\(const iocshArgBuf *args)\n";
+         print "{\n";
+         print "    " . $funcname . "\(";
+         for ($k = 0; $k < $j; $k++) {
+            print "args\[" . $k . "\]\.";
+            if (@types[$k] eq "iocshArgInt") {
+               print "ival"; }
+            if (@types[$k] eq "iocshArgString") {
+               print "sval"; }
+            if (@types[$k] eq "iocshArgDouble") {
+               print "dval"; }
+            if (($k + 1) < $j) {
+                print ","; 
+            } else { print "\);\n"}
+         }
+         print "}\n";
+      }
+      ($type, $funcname) = split(/\s+/,@outlist[$i]);
+      ($funcname, $junk) = split(/\(/,$funcname);
+      $i++;
+      @names = "";
+      @types = "";
+      $j = 0;
+      @args = split;
+      $typefound = 0;
+      $charfound = 0;
+      foreach (@args) {
+         if ($charfound == 2) {
+            $charfound = 0;
+            @types[$j] = "iocshArgString";
+            if (/,$/) { chop($_); }
+            @names[$j] = $_;
+            $funcfound = 1;
+            print "static const iocshArg " . $funcname . "Arg" . $j . " = { ";
+            print "\"". @names[$j] . "\",". @types[$j] . " };\n";
+            $j++;
+            next;
+         }
+         if ($charfound == 1 && /\*/ && length($_) == 1) { 
+            $charfound = 2;
+            next;
+         }
+         if ($charfound == 1 && /\*/ ) { 
+            s/\*//;
+            $charfound = 0;
+            @types[$j] = "iocshArgString";
+            if (/,$/) { chop($_); }
+            @names[$j] = $_;
+            $funcfound = 1;
+            print "static const iocshArg " . $funcname . "Arg" . $j . " = { ";
+            print "\"". @names[$j] . "\",". @types[$j] . " };\n";
+            $j++;
+            next;
+         }
+         if ($charfound == 1) {
+            $charfound = 0;
+            @types[$j] = "iocshArgInt";
+            if (/,$/) { chop($_); }
+            @names[$j] = $_;
+            $funcfound = 1;
+            print "static const iocshArg " . $funcname . "Arg" . $j . " = { ";
+            print "\"". @names[$j] . "\",". @types[$j] . " };\n";
+            $j++;
+            next;
+         }
+         if (/char/) {
+            $charfound = 1;
+            next;
+         }
+         if (/unsigned/) {
+            $unsfound = 1;
+            next;
+         }
+         if ($intfound == 1) {
+            $intfound = 0;
+            @types[$j] = "iocshArgInt";
+            if (/,$/) { chop($_); }
+            @names[$j] = $_;
+            $funcfound = 1;
+            print "static const iocshArg " . $funcname . "Arg" . $j . " = { ";
+            print "\"". @names[$j] . "\",". @types[$j] . " };\n";
+            $j++;
+            next;
+         }
+         if ($unsfound == 1 || /char|int|long|short/) {
+            $unsfound = 0;
+            $intfound = 1;
+            next;
+         }
+         if ($doublefound ==1) {
+            $doublefound = 0;
+            @types[$j] = "iocshArgDouble";
+            if (/,$/) { chop($_); }
+            @names[$j] = $_;
+            $funcfound = 1;
+            print "static const iocshArg " . $funcname . "Arg" . $j . " = { ";
+            print "\"". @names[$j] . "\",". @types[$j] . " };\n";
+            $j++;
+            next;
+         }
+         if (/double|float/) {
+            $doublefound = 1;
+            next;
+         }
+      }
+   }
+#
+# this needs to be done one more time for the last function...
+#
+
+      if ($funcfound == 1) {
+         $funcfound = 0;
+         print "static const iocshArg * const ".$funcname."Args\[" . $j ."\] = {\n";
+         for ($k = 0; $k < $j; $k++) {
+            print "       &" . $funcname . "Arg" . $k;
+            if (($k + 1) < $j) {
+                print ",\n"; 
+            } else { print "\};\n"}
+         }
+         print "static const iocshFuncDef " . $funcname . "FuncDef = {";
+         print "\"". $funcname ."\"," . $j . "\," . $funcname."Args};\n";
+         print "static void " . $funcname . "CallFunc\(const iocshArgBuf *args)\n";
+         print "{\n";
+         print "    " . $funcname . "\(";
+         for ($k = 0; $k < $j; $k++) {
+            print "args\[" . $k . "\]\.";
+            if (@types[$k] eq "iocshArgInt") {
+               print "ival"; }
+            if (@types[$k] eq "iocshArgString") {
+               print "sval"; }
+            if (@types[$k] eq "iocshArgDouble") {
+               print "dval"; }
+            if (($k + 1) < $j) {
+                print ","; 
+            } else { print ");\n"}
+         }
+         print "}\n";
+      }
+#
+#  end of last function work
+
+#
+# produce registrar function
+#
+print "\n";
+print "void xxxRegister(void)\n";
+print "{\n";
+
+
+foreach (@outlist) {
+      ($type, $funcname) = split(/\s+/,$_);
+      ($funcname, $junk) = split(/\(/,$funcname);
+
+   print "   iocshRegister(&" . $funcname . "FuncDef, " . $funcname . "CallFunc)\;\n";
+}
+
+print "}\n";
+
+print "epicsExportRegistrar(xxxRegister)\;\n";
+
